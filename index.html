<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>title</title>
  <!-- <link rel="stylesheet" href="style.css"> -->
  <script src="//d3js.org/d3.v2.min.js" charset="utf-8"></script>
  <!-- <script src="script.js"></script> -->
  <style>
    body {
      font: 11px sans-serif;
    }

    .axis path,
    .axis line {
      fill: none;
      stroke: #000;
      shape-rendering: crispEdges;
    }

    .circle {
      fill: #000;
    }
  </style>
</head>

<body>
  <!-- page content -->
  <p id="chart"></p>
  <p id="xMenu"><b>X axis: </b><select></select></p>
  <p id="yMenu"><b>Y axis: </b><select></select></p>
  <p id="colourMenu"><b>Colour: </b><select></select></p>
  <!-- legend -->
</body>
<script>
  var margin = {
      top: 20,
      right: 20,
      bottom: 30,
      left: 40
    },
    width = 960 - margin.left - margin.right,
    height = 250 - margin.top - margin.bottom;

  var svg = d3.select("#chart").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  svg.append("g")
    .attr("class", "y axis");
  // .attr("transform", "translate(" + margin.left + ",0)");

  svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + (height) + ")");

  var xMenu = d3.select("#xMenu select")
    .on("change", change);
  var yMenu = d3.select("#yMenu select")
    .on("change", change);
  var colourMenu = d3.select("#colourMenu select")
    .on("change", change);

  d3.json("responses.php", function(data) {
    surveyResponses = data.data;
    var attributes = d3.keys(surveyResponses[0]);

    xMenu.selectAll("option")
      .data(attributes)
      .enter().append("option")
      .text(function(d) {
        return d;
      });
    yMenu.selectAll("option")
      .data(attributes)
      .enter().append("option")
      .text(function(d) {
        return d;
      });
    colourMenu.selectAll("option")
      .data(attributes)
      .enter().append("option")
      .text(function(d) {
        return d;
      });

    //menu.property("value", "18 to 24 Years");

    change();
  });

  var altKey;

  d3.select(window)
    .on("keydown", function() {
      altKey = d3.event.altKey;
    })
    .on("keyup", function() {
      altKey = false;
    });

  function change() {
    // clearTimeout(timeout);

    xAxisAtt = xMenu.property("value");
    yAxisAtt = yMenu.property("value");
    colourAtt = colourMenu.property("value");

    var xDomain = [
      d3.min(surveyResponses, function(d) {
        return d[xAxisAtt];
      }),
      d3.max(surveyResponses, function(d) {
        return d[xAxisAtt];
      })
    ];
    var yDomain = [
      d3.min(surveyResponses, function(d) {
        return d[yAxisAtt];
      }),
      d3.max(surveyResponses, function(d) {
        return d[yAxisAtt];
      })
    ];

    // Set the functions
    x = d3.scale.linear().domain(xDomain).range([0, width]);
    y = d3.scale.linear().domain(yDomain).range([height, 0]);

    // Update the Axis
    var xAxis = d3.svg.axis().scale(x).orient("bottom");
    var yAxis = d3.svg.axis().scale(y).orient("left");
    svg.selectAll("g .y.axis")
      .call(yAxis)
    svg.selectAll("g .x.axis")
      .call(xAxis);

    // setup fill color
    colour = d3.scale.category10();

    d3.transition()
      .duration(altKey ? 3000 : 1200)
      .each(redraw);
  }

  function redraw() {

    var aggregated = [];
    for (response of surveyResponses) {
      var xAtt = response[xAxisAtt],
        yAtt = response[yAxisAtt];
      var xList = aggregated[xAtt];
      if (!xList) {
        xList = [];
        aggregated[xAtt] = xList;
      }

      var yList = xList[yAtt];
      if (!yList) {
        yList = [];
        xList[yAtt] = yList;
      }

      yList.push(response.id);
      response.list = yList;
    }

    var gSel = svg.selectAll(".response")
      .data(surveyResponses, function(d) {
        return d.id;
      });

    var gEnter = gSel.enter()
      .append("g")
      .attr("class", "response")
      .attr("transform", function(d) {
        var listLength = d.list.length;
        var positionInList = d.list.indexOf(d.id);
        // console.log("yo, ", positionInList);
        var rotation = 360 / listLength * positionInList;

        return "translate(" + x(d[xAxisAtt]) + "," + y(d[yAxisAtt]) //+ ")";
           +") rotate(" + rotation + ")";
      })
      .append("path").attr("class", "pieSlice")
      .on("click", function (d) {"!", console.log(d)});

    // .append("circle").attr("class", "circle")
    // .attr("cx", 0).attr("cy", 0).attr("r", 10);

    var gUpdate = d3.transition(gSel)
      .attr("transform", function(d) {
        var listLength = d.list.length;
        var positionInList = d.list.indexOf(d.id);
        // console.log("yo, ", positionInList);
        var rotation = 360 / listLength * positionInList;

        return "translate(" + x(d[xAxisAtt]) + "," + y(d[yAxisAtt]) //+ ")";
          +") rotate(" + rotation + ")";
      });

    var sliceUpdate = d3.transition(gSel.selectAll(".pieSlice"))
      .attr("d", function(d) {
        return getPieSliceArcPath(d);
      })

      //   .attr("cx", function(d) {
      //     return x(d[xAxisAtt]);
      //   })
      //   .attr("cy", function(d) {
      //     return y(d[yAxisAtt]);
      //   });

      // var circleUpdate = d3.transition(circle)
      //   .attr("cx", function(d) {
      //     return x(d[xAxisAtt]);
      //   })
      //   .attr("cy", function(d) {
      //     return y(d[yAxisAtt]);
      //   })
      //   .attr("r", function(d){
      //     return d.list.length;
      //   })
      .style("fill", function(d) {
        return colour(d[colourAtt]);
      });

    gSel.exit().remove();

  }

  getPieSliceArcPath = function(response) {
    var listLength = response.list.length;
    // var positionInList = d.list.indexOf(d.id);

    var startAngle = 0; //((annotation.fstart - 1) / this.participant.size) * 360;
    var endAngle = 20;// 360 / listLength; //(annotation.fend / this.participant.size) * 360;
    //just in case
    // if (startAngle > endAngle) {
    //   var temp = startAngle;
    //   startAngle = endAngle;
    //   endAngle = temp;
    // }
    var largeArcFlag = 0,
      sweepFlag = 1;
    if ((endAngle - startAngle) > 180) { //|| (endAngle - startAngle) == 0) {
      largeArcFlag = 1;
    }
    //hacky
    //actually its not clear there is better solution -
    // https://stackoverflow.com/questions/5737975/circle-drawing-with-svgs-arc-path
    // if (listLength == 1) {
    //   startAngle = 0.1;
    //   endAngle = 359.9;
    //   sweepFlag = 1;
    //     largeArcFlag = 1;
    // }

    var radius = Math.sqrt(response.list.length / Math.PI) * 20; //20;//this.getBlobRadius() - 2;
    var arcStart = trig(radius, startAngle - 90);
    var arcEnd = trig(radius, endAngle - 90);
    return "M0,0 L" + arcStart.x + "," + arcStart.y + " A" + radius + "," +
      radius + " 0 " + largeArcFlag + " " + sweepFlag + " " + arcEnd.x + "," + arcEnd.y + " Z";
  };

  trig = function(radius, angleDegrees) {
    //x = rx + radius * cos(theta) and y = ry + radius * sin(theta)
    var radians = (angleDegrees / 360) * Math.PI * 2;
    return {
      x: (radius * Math.cos(radians)),
      y: (radius * Math.sin(radians))
    };
  };
  // var timeout = setTimeout(function() {
  //   menu.property("value", "65 Years and Over").node().focus();
  //   change();
  // }, 5000);
</script>

</html>
